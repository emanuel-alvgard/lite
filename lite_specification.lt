#/
* lite uses 4 white-space indentation for scoping but can also be written without indentation.
* object lifetime is always scope bound
* no aliasing, except for imports
* parameters and assignments are always passed by value
* type data are stored as SOA
* lite is a small language that compiles to langs like wasm/js, C, Rust etc. It will ultimately serve as a kind of language interface.
* lite is completely stack based and all data is stored as SOA.
* variables can only be overwritten to the same type. Variables containing an array can 
can only be overwritten by an array of the same type and size.  
* all type functions can be applied to an array of that type by default.
* arithmetic operators are +, -, *, /. These can only be used on primitive types.
* comparison operators are =, >, <, !=, !>, !<.
/#



#/
* primitive data types/structures: u8-64, s8-64, f32-64, str, [array](generic structure). What types are avalible will vary with the underlying implementation. if type annotation is left
out the compiler will automatically infer the type to it's smallest form.
/#



# compiler variables
STACK: '64MB'              # stack size
THREADS: 3                 # thread pool

# relative or absolute imports with aliasing and specific importing
import mod_0: 'module_0.lt'
import '../module_1.lt'.some_function



type Vector3:
    x: f32
    y: f32
    z: f32

type Entity:
    id: u32
    position: Vector3

type Line:   
    id: str
    start: Vector3
    end: Vector3

    function unique_type_func:
        pass
   


# type inference of primitive types
variable_0: 1                           # u32
variable_1: 2500000                     # u64
variable_2: 1.0                         # f32
variable_3: 1.00000000                  # f64
variable_4: 'this is a string'          # str

# zero initialized with 3 items
num_array: f64 [3]
num_array[0]: 10.0
num_array[1]: 11.0
num_array[2]: 12.0

string_array: str [3]
string_array[0]: 'string 0'
string_array[1]: 'string 1'
string_array[2]: 'string 2'

# direct initialization
vector_array: [Vector2(0.0, 0.0, Vector2(0.0, 0.0)]     # inferred to Vector2 based on first item     



some_array: Vector3 [128]  
lock some_array             # makes the variable immutable

thread:
    loop i < some_array:           # for
        if some_array[i].x = 1.0:
            pass
        else if some_array[i].x = 2.0:
            fail 'this stops execution'
        else:
            exit
        i ++
        
thread:
    loop i = 1:                    # while
        i: 0
        
unlock some_array          # makes the variable mutable again

        
function get_position_of_entities: Vector3  
    (entities: Entity)
    (param_2: Vector3)

    result: Vector3 [entities]
    
    loop i < entities:
        result[i]: enitities[i].position
        i ++
        
    return result       



lines: Line [128]                          # array contains 128 0-initialized Lines.
line_0: lines[0]                            # indexed value gets copied in memory by the compiler.
line_0.start: Vector3(1.0, 1.0, 1.0)
lines[0]: line_0                            # indexed value gets overwritten with line_0's value
lines[0].id: 'some string'



# generic function since both primitive and custom types are iterable
function generic_func: []
    (input_0)
    (input_1)
    result: input_0 [input_0]               # creates an array with length of input_0 and of type input_0 (this is evaluated at runtime)
    #some generic array manipulation
    
    return result


# arithmetic expression
some_new_var: ((1 + 1) + (2 * 3) + 1) / 4



# threading example
function compare3: i32

    (x: [])
    (other_x: [])
    (y: [])
    (other_y: [])
    (z: [])
    (other_z: [])

    result_0: u8 [x + y + z]
    
    {1}
    loop i < x:
        if x[i] == other_x[i]:
            result_0[i * 3]
        i ++

    {2}
    loop i < y:
        if y[i] == other_y[i]:
            result_0[(i * 3) + 1]: 1
        else:
            pass
        i ++

    {3}
    loop i < z:
        if z[i] = other_z[i]:
            result_0[(i * 3) + 2]: 1
        else:
            pass
        i ++
    
    {0}
    result_1: u8 [x]
    loop i < result_0:
        
        if result_0[i * 3] = 1
        & result_0[(i * 3 + 1)] = 1  # implicit line break??
        & result_0[(i * 3 + 2)] = 1:
            result_1[i]: 1
        
        else:
            pass

    return result_1



{1} # threads are scoped but they do not define scope
var_1: compare3(x, x_other, y, y_other, z, z_other)
var_2: do_something()
var_3: do_something_else()

{0}
do_unrelated()
do_related({1}.var_1) # will defer this function call until 'var_1' has returned




# keywords
#/ 
import, type, function, return, loop, 
if, else if, else, pass, exit, fail,
lock, unlock, allocate
/#
