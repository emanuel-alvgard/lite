#/
* lite uses 4 white-space indentation for scoping but can also be written without indentation.
* object lifetime is always scope bound
* no aliasing, except for imports
* parameters and assignments are always passed by value
* lite is a small language that compiles to readable C. It will ultimately serve as a kind of language interface.
* lite is completely stack based and all data is stored as SOA.
* all variables are arrays. This means that all varaibles are iterable.
* variables can only be overwritten to the same type. 
* arithmetic operators are +, -, *, /, %, ++, --. These can only be used on primitive types.
* comparison operators are =, >, <, !=, !>, !<.
/#


#/ primitive data types/structures: none, u8-64, s8-64, f32-64, str, [array](generic structure). What types are avalible will vary with the underlying implementation. if type annotation is left
out the compiler will automatically infer the type to it's largest form. /#



# compiler variables
STACK: '64MB'              # stack size
THREADS: 3                 # thread pool

# relative or absolute imports with aliasing and specific importing
import mod_0: 'module_0.lt'
import '../module_1.lt'.some_function



# the compiler just copy paste this code in to the generated C file
inline:
    #include <string.h>

    int some_c_function()
    {
        printf('Hello!');
    }


type Vector3:
    x: f32
    y: f32
    z: f32

type Entity:
    id: u32
    position: Vector3

type Line:   
    id: str
    start: Vector3
    end: Vector3

    function unique_type_func:
        parameter_0: (Vector2)
        parameter_1: (Vector2)
        parameter_2: (Vector2)
        return
   


# type inference of primitive number types default to it's largest type
variable_0: 1                           # s64
variable_1: 2500000                     # s64
variable_2: 1.0                         # f64
variable_3: 1.00000000000               # f64
variable_4: 'this is a string'          # str

# inferred arrays based on first item
array_0: 1, 1
array_1: 2500000, 2500000
array_2: 1.0, 1.0
array_3: 1.00000000000, 1.00000000000
array_4: 1, 2, 3, 4, 5


# explicit typing
variable_0: u8 1                          
variable_1: u16 25000000                
variable_2: f32 1.0                       
variable_3: f64 1..000000000
variable_4: Vector3 (1.0, 1.0, 1.0)                 
variable_5: 'this is a string'          # strings can only be inferred         


# zero initialized array
num_array: [1024] u8

loop i < num_array:
    num_array[i]: i
    i: ++


num_array_1: f32
    1.0, 1.0, 1.0, 1.0,
    2.0, 2.0, 2.0, 2.0,
    3.0, 3.0, 3.0, 3.0,


string_array: 'string 0', 'string 1', 'string 2'


vector_array: Vector3 
    (1.0, 1.0, 0.0),
    (1.0, 1.0, 0.0),
    (1.0, 1.0, 0.0),
    (1.0, 1.0, 0.0)      


if vector_array[0].x = 0.0
| vector_array[1].x = 0.0 
& vector_array[2].x = 0.0:
    pass

assigment_0: f32 10.0
assigment_0: + 5.0
assigment_0: - 5.0
assigment_0: * 5.0
assigment_0: / 5.0
assigment_0: % 5.0
assigment_0: ++
assigment_0: --


some_array: [128] Vector3    
lock some_array                # makes the variable immutable


{1}
loop i < some_array:           # for
    if some_array[i].x = 1.0:
        pass
    else if some_array[i].x = 2.0:
        fail 'this stops execution'
    else:
        exit
    i: ++
        
{0}
loop i = 1:                    # while
    i: 0
        
unlock some_array              # makes the variable mutable again

        
function get_position_of_entities: Vector3  
    entities: (Entity)
    param_2: (Vector3)

    result: [entities] Vector3
    
    loop i < entities:
        result[i]: enitities[i].position
        i: ++
        
    return result    



lines: [128] Line                           # array contains 128 0-initialized Lines.
line_0: lines[0]                            # indexed value gets copied in memory by the compiler.
line_0.start: Vector3 (1.0, 1.0, 1.0)
lines[0]: line_0                            # indexed value gets overwritten with line_0's value
lines[0].id: 'some string'



# generic function since both primitive and custom types are iterable
function generic_func:
    input_0: ()
    input_1: ()
    result: [input_0] input_0              # creates an array with length of input_0 and of type input_0 (this is evaluated at runtime)
    # some generic array manipulation
    
    return result


# arithmetic expression with impilicit type
some_new_var: ((1 + 1) + (2 * 3) + 1) / 4               #inferred to s64

# arithmetic expression with explicit type
some_new_var: f32 ((1.0 + 1.0) + (1.0 * 1.0) + 1.0) / 1.0   

#/ primitive number types are interchangeble with arithmetic operations, 
which type is used during such an operation is fully dependent on the type
of the target variable. If the target have no type it will as usual be
inferred to it's largest signed version. /#



# threading example
function compare3:

    x: (), y: (), z: ()
    other_x: ()
    other_y: ()
    other_z: ()

    result_0: [x + y + z] u8
    
    {1}
    loop i < x:
        if x[i] = other_x[i]:
            result_0[i * 3]: 1
        i: ++

    {2}
    loop i < y:
        if y[i] = other_y[i]:
            result_0[(i * 3) + 1]: 1
        else:
            pass
        i: ++

    {3}
    loop i < z:
        if z[i] = other_z[i]:
            result_0[(i * 3) + 2]: 1
        else:
            pass
        i: ++
    
    {0}
    result_1: [x] u8
    loop i < result_0:
        
        if result_0[i * 3] = 1
        & result_0[(i * 3 + 1)] = 1
        & result_0[(i * 3 + 2)] = 1:
            result_1[i]: 1
        
        else:
            pass

    return result_1


{1} # threads are scoped but they do not define scope
var_1: compare3(x, x_other, y, y_other, z, z_other)
var_2: do_something()
var_3: do_something_else()

{0}
var_4: do_unrelated()
var_5: do_related({var_1}, some_var) # will defer this function call until 'var_1' has returned
var_6: do_something_else()



# keywords
#/ 
import, type, function, return, loop, 
if, else if, else, pass, exit, fail,
lock, unlock, allocate, inline
/#
