#/
* lite uses 4 white-space indentation for scoping but can also be written without indentation.
* object lifetime is always scope bound
* no aliasing, except for imports
* assignments are always passed by value. When passing arguments primitives are passed by value and user defined types passed by reference.
* lite is a small language that compiles to readable C. It will ultimately serve as a kind of language interface.
* lite is completely stack based and all data is stored as SOA.
* all variables are arrays. This means that all varaibles are iterable.
* variables can only be overwritten to the same type. 
* arithmetic operators are +, -, *, /, %, ++, --. These can only be used on primitive types.
* comparison operators are =, >, <, !=, !>, !<.
* threads can only read other threads varaiables and do atomic i.e(not ++, --) operations on shared variables.
/#


#/ primitive data types/structures: none, u8-64, s8-64, f32-64, str, [array](generic structure). What types are avalible will vary with the underlying implementation. if type annotation is left
out the compiler will automatically infer the type to it's largest form. /#



# compiler variables
STACK: '64MB'              # stack size
THREADS: 3                 # thread pool



# relative or absolute imports with aliasing and specific importing
import mod_0: 'module_0.lt'
import '../module_1.lt'.some_function



# the compiler just copy paste this code in to the generated C file
inline:
    #include <string.h>

    int some_c_function()
    {
        printf('Hello!');
    }


type Vector3:
    x: f32
    y: f32
    z: f32

type Entity:
    id: u32
    position: Vector3

type Line:   
    id: str
    start: Vector3
    end: Vector3

    function unique_type_func: none
        parameter_0: (Vector2)
        parameter_1: (Vector2)
        parameter_2: (Vector2)
        return
   


# type inference of primitive number types default to it's largest type
variable_0: 1                           # s64
variable_1: 2500000                     # s64
variable_2: 1.0                         # f64
variable_3: 1.00000000000               # f64
variable_4: 'this is a string'          # str

# inferred arrays based on first item
array_0: 1, 1
array_1: 2500000, 2500000
array_2: 1.0, 1.0
array_3: 1.00000000000, 1.00000000000
array_4: 1, 2, 3, 4, 5


# explicit typing
variable_0: u8 1                          
variable_1: u16 25000000                
variable_2: f32 1.0                       
variable_3: f64 1..000000000
variable_4: Vector3 (1.0, 1.0, 1.0)                 
variable_5: 'this is a string'          # strings can only be inferred         


# zero initialized array
num_array: [1024] u8 0

if [num_array] = 0:         # this if statement will be looped 1024 times.
    print('yes')

i: 0
[num_array]: i
    i: ++
    


{t1}
some_input: [3] str
allocate [some_input]: read()

if [some_input].substring('hello'):  # if statement will be looped 3 times.
    print('true')
else:
    print('false')

free some_input # if not freed some_input will be freed when out of scope

{main}
num_array_1: f32
    1.0, 1.0, 1.0, 1.0,
    2.0, 2.0, 2.0, 2.0,
    3.0, 3.0, 3.0, 3.0,

# assigment examples
string_array: 'string 0', 'string 1', 'string 2'


# NOT DONE!!
new_string_array: [1024] str "init"           # Initializes the array with 1024 "init" strings
new_string_array_1: string_array              # copies only the first element into the first index of the array
new_string_array_2: string_array[1]           # copies only the indexed item
[new_string_array_2]: "test"                  # copies "test" into every index of array
[new_string_array_0]: [string_array]          # copies all items of string_array_0 into new_string_array



vector_array: Vector3 
    (1.0, 1.0, 0.0),
    (1.0, 1.0, 0.0),
    (1.0, 1.0, 0.0),
    (1.0, 1.0, 0.0)      


if vector_array[0].x = 0.0
| vector_array[1].x = 0.0 
& vector_array[2].x = 0.0:
    pass
else:
    pass

assigment_0: f32 10.0
assigment_0: + 5.0
assigment_0: - 5.0
assigment_0: * 5.0
assigment_0: / 5.0
assigment_0: % 5.0
assigment_0: ++
assigment_0: --


some_array: [128] Vector3    
lock some_array                # makes the variable immutable


{thread}
if [some_array].x = 1.0:
    pass
else if [some_array].x = 2.0:
    fail 'this stops execution'
else:
    exit

        
{main}
loop:                    # while
    exit
        
unlock some_array              # makes the variable mutable again

        
function transform_position_of_entities: none  
    entities: (Entity)
    transform: (Vector3)
    
    [enitities].position.x: * [transform].x 
    [enitities].position.y: * [transform].y 
    [enitities].position.z: * [transform].z
        
    return    



lines: [128] Line                           # array contains 128 0-initialized Lines.
line_0: lines[0]                            # indexed value gets copied in memory by the compiler.
line_0.start: Vector3 (1.0, 1.0, 1.0)
lines[0]: line_0                            # indexed value gets overwritten with line_0's value
lines[0].id: 'some string'



# generic function since both primitive and custom types are iterable
function generic_func: []
    input_0: ()
    input_1: ()
    result: [input_0] input_0              # creates an array with length of input_0 and of type input_0 (this is evaluated at runtime)
    # some generic array manipulation
    
    return result

some_new_var: u8 0, 0, 0

# arithmetic expression
[some_new_var]: ((1 + 1) + (2 * 3) + 1) / 4      

# arithmetic expression with explicit type
some_new_var_1: f32 ((1.0 + 1.0) + (1.0 * 1.0) + 1.0) / 1.0   

#/ primitive number types are interchangeble with arithmetic operations, 
which type is used during such an operation is fully dependent on the type
of the target variable. If the target have no type it will as usual be
inferred to it's largest signed version. /#



# threading example
function compare3: u8

    x: (), y: (), z: ()
    other_x: ()
    other_y: ()
    other_z: ()

    shared result_0: [x + y + z] u8
    
    {t1}
    if [x] = [other_x]:
        [result_0 * 3]: 1

    {t2}
    if [y] = [other_y]:
        [(result_0 * 3) + 1)]: 1

    {t3}
    lif [z] = [other_z]:
        [(result_0 * 3) + 2)]: 1
    
    {main}
    result_1: [x] u8
    
    if [result_0 * 3] = 1
    & [(result_0 * 3) + 1)] = 1
    & [(result_0 * 3) + 2)] = 1:
        [result_1]: 1

    return result_1


{0} # threads are scoped but they do not define scope
var_1: compare3(x, x_other, y, y_other, z, z_other)
var_2: do_something()
var_3: do_something_else()

{main}
var_4: do_unrelated()
var_5: do_related(var_1) # will automatically defer this function call until 'var_1' has returned.
var_6: do_something_else() # if var_1 has not returned, this function will be executed before do_related().



# keywords
#/ 
import, type, function, return, loop, 
if, else if, else, pass, exit, fail,
lock, unlock, allocate, free, inline, shared
/#
