#/
* lite uses 4 white-space indentation for scoping but can also be written without indentation.
* object lifetime is always scope bound
* no aliasing, except for imports
* parameters and assignments are always passed by value
* type data are stored as SOA
* lite is a small language that compiles to langs like wasm/js, C, Rust etc. It will ultimately serve as a kind of language interface.
* lite is completely stack based and all data is stored as SOA.
* variables can only be overwritten to the same type. Variables containing an array can 
can only be overwritten by an array of the same type and size.  
* all type functions can be applied to an array of that type by default.
* arithmetic operators are +, -, *, /. These can only be used on primitive types.
* comparison operators are =, >, <, !=, !>, !<.
/#



#/
* primitive data types/structures: i32,64, f32,64, str, array(structure). What types are avalible will vary with the underlying implementation. if type annotation is left
out the compiler will automatically infer the type to either i32, f32 or string.
/#

#compiler variables
MEMORY: '64MB'              #stack size
OPTIMIZATION: '1'
THREADS: 3

#relative or absolute imports with aliasing and specific importing
import 'module_0.lt' as mod_0
import '../module_1.lt'.some_function

protocol Selectable:
    function hover_start:
    function hover_end:
    function select_start:
    function select_end:

type Vector3:
    x: f32
    y: f32
    z: f32

type Entity:
    id: i32
    position: Vector3

type Line:   
    id: str
    start: Vector3
    end: Vector3

    function unique_type_func:
        pass

    {Selectable}
        function hover_start:
            (input_0: Vector3)
            (inptu_1: Vector3)
            return

        function hover_end:
            pass
        function select_start:
            pass
        function select_end:
            pass
   


#type inference of primitive types
variable_0: 1                           #i32
variable_1: 2500000                     #i64
variable_2: 1.0                         #f32
variable_3: 1.00000000                  #f64
variable_4: 'this is a string'          #str

num_array: [3] f64: [1.0, 3.0, 4.0]
num_array[0]: 10.0
num_array[1]: 11.0
num_array[2]: 12.0

string_array: [3] str
string_array[0]: 'string 0'
string_array[1]: 'string 1'
string_array[2]: 'string 2'



some_array: [128] Vector3   
lock some_array             #makes the variable immutable

thread:
    loop i < some_array:           #for
        if some_array[i].x = 1.0:
            pass
        else if some_array[i].x = 2.0:
            pass
        else:
            exit
        i ++
thread:

    loop i = 1:                    #while
        i: 0
        
unlock some_array          #makes the variable mutable again

        
 function get_position_of_entities: Vector3
        
    (entities: Entity)
    (param_2: Vector3)

    result: [entities] Vector3 
    
    for i in entities:
        result[i]: enitities[i].position
    
    return result       



lines: [128] Line                           #array contains 128 0-initialized Lines.
line_0: lines[0]                            #indexed value gets copied in memory by the compiler.
line_0.start: Vector3(1.0, 1.0, 1.0)
lines[0]: line_0                            #indexed value gets overwritten with line_0's value
lines[0].id: 'some string'





#keywords
#/ import, as, protocol, type, function, return, loop, 
    if, else if, else,
    and, or, pass, exit, thread,
    lock, unlock /#
