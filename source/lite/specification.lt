#/
* lite uses 4 white-space indentation for scoping but can also be written without indentation.
* object lifetime is always scope bound
* no aliasing, except for imports
* assignments are always passed by value. When passing arguments primitives are passed by value and user defined types passed by reference.
* lite is a small language that compiles to readable C. It will ultimately serve as a kind of language interface.
* lite is completely stack based and all data is stored as SOA.
* all variables are arrays. This means that all varaibles are iterable.
* variables can only be overwritten to the same type. 
* arithmetic operators are +, -, *, /, %, ++, --. These can only be used on primitive types.
* comparison operators are =, >, <, !=, !>, !<.
* threads can only read other threads varaiables and do atomic i.e(not ++, --) operations on shared variables.
* lite only uses procedures with multiple dispatch.
* lite does not allow variable shadowing.
/#


#/ 
primitive data types/structures: none, type, u1-8 (unsigned), 
i1-8 (signed), f4-8 (float), s(x) (string), _(custom), [array](generic structure). 
What types are avalible will vary with the underlying implementation. if type annotation is left
out the compiler will automatically infer the type to it's largest form. 
/#



# builtin funciton keywords
@ = optional parameter
write(text(string), @string(filepath)): none
read(@filepath(string), @offset_start(integer), @length(integer)): string
append(text(string), @filepath(string))
create(name(string)): filepath(string)
delete(filepath(string)): none
save(target(variable), filepath(string)): none
load(target(string), filepath(string)): []
evaluate(text(string)): none
terminate(message(string)): none


# specifying which package this module belongs to
package main


# relative or absolute imports with aliasing and specific importing
import alias: "./some_file.lt"

import:
	"./some_other_file_0".some_func
	"./some_other_file_1".some_other_func



# the compiler just copy paste this code in to the generated C file
inline:
    #include <string.h>

    int some_c_function()
    {
        printf('Hello!');
    }

primitive _color:       # custom primitives are always implemented as u2
    red, green, blue

primitive _country:
    sweden, norway, denmark,
    spain, portugal, brazil
    
primitive _bool:
    true, false


composite Vector2:
    x: f4
    y: f4
    z: f4

composite Entity:
    id: u2
    color: _color
    position: Vector3
    burning: _bool

composite Line:   
    id: str
    start: Vector3
    end: Vector3


procedure (+): Vector2
    input_0: (Vector2)
    input_1: (Vector2)

    x: input_0.x + input_1.x
    y: input_0.y + input_1.y
    
    result: Vector2 (x, y)
    return result

test_vector: Vector2 (1.0, 1.0) + Vector2 (2.0, 2.0)
# test_vector = Vector2 (3.0, 3.0)    


# type inference of primitive number types default to it's largest type
variable_0: 1                           # i1
variable_1: 2500000                     # i4
variable_2: 1.0                         # f4
variable_3: 1.00000000000               # f8
variable_4: "/ this is a 
            multiline string /"          # s16


# inferred arrays based on first item
array_0: 1, 1
array_1: 2500000, 2500000
array_2: 1.0, 1.0
array_3: 1.00000000000, 1.00000000000
array_4: 1, 2, 3, 4, 5


# explicit typing
variable_0: u1 1                          
variable_1: u2 25000000                
variable_2: f4 1.0                      
variable_3: f8 1.000000000
variable_4: Vector3 (1.0, 1.0, 1.0)                 
variable_5: s16 "this is a string"
variable_6: _color green
variable_7: _bool true



# zero initialized array 
num_array: u1 [1024] 0

if num_array != 1:         # this if statement will be looped 1024 times.
    write("&(num_array[i])")
else:
    write("false")



some_input_0:                 # stack allocation
allocate some_input: read()   # heap allocation of 3 items the each the size of read()'s return value

if some_input.substring("hello"):  # if statement will be looped 3 times.
    write("true")
else:
    write("false")

free some_input # if not freed some_input will be freed when out of scope

num_array_1: f4
    1.0, 1.0, 1.0, 1.0,
    2.0, 2.0, 2.0, 2.0

# assigment examples
string_array: s1 
    "string 0", "string 1", "string 2"


# NOT DONE!!
new_string_array: s8 [1024] "init"          # Initializes the array with 1024 s1 "init" strings
new_string_array_2: string_array[1]           # copies only the indexed item to the first item in the array
new_string_array_2[1]: string_array[1]        # copies from/to specified index
new_string_array_2: "test"                  # copies "test" into every index of array. can only be done to existing arrays
new_string_array_0: string_array          # copies all items of string_array_0 into new_string_array



vector_array: Vector3 
    (1.0, 1.0, 0.0),
    (1.0, 1.0, 0.0),
    (1.0, 1.0, 0.0),
    (1.0, 1.0, 0.0)      


if vector_array[0].x = 0.0
| vector_array[1].x = 0.0 
& vector_array[2].x = 0.0:
    skip
else:
    skip

assigment_0: f4 10.0
assigment_0: + 5.0
assigment_0: - 5.0
assigment_0: * 5.0
assigment_0: / 5.0
assigment_0: % 5.0
assigment_0: ++
assigment_0: --


some_array: Vector3 [128]   
lock some_array                # makes the variable immutable


{t1}
if some_array[i].x = 1.0:
    skip
else if some_array[i].x = 2.0:
    skip
else:
    exit

        
{main} 
loop some_array[i]:                    # iterator and incrementer
    if some_array[i] = 0:
        skip
    else: 
        exit

loop 1000[i]: write("&(i)")
        
unlock some_array              # makes the variable mutable again

        
procedure transform_position_of_entities: none  
    entities: (Entity)
    transform: (Vector3)
    
    enitities.position.x: * transform.x 
    enitities.position.y: * transform.y 
    enitities.position.z: * transform.z
        
    return    



lines: Line [128]                           # array contains 128 0-initialized Lines.
line_0: lines[0]                            # indexed value gets copied in memory by the compiler.
line_0.start: Vector3 (1.0, 1.0, 1.0)
lines[0]: line_0                            # indexed value gets overwritten with line_0's value
lines[0].id: "some string"



# generic function since both primitive and custom types are iterable
procedure generic_func: type
    input_0: (type)
    input_1: (type)
    result: input_0 [input_0]              # creates an array with length of input_0 and of type input_0 (this is evaluated at runtime)
    # some generic array manipulation
    
    return result

some_new_var: u1 0, 0, 0

# arithmetic expression
some_new_var: ((1 + 1) + (2 * 3) + 1) / 4      

# arithmetic expression with explicit type
some_new_var_1: f4 ((1.0 + 1.0) + (1.0 * 1.0) + 1.0) / 1.0   

#/ primitive number types are interchangeble with arithmetic operations, 
which type is used during such an operation is fully dependent on the type
of the target variable. If the target have no type it will as usual be
inferred to it's largest signed version. /#



# threading example
procedure compare3: u1

    x: (type), y: (type), z: (type)
    other_x: (type)
    other_y: (type)
    other_z: (type)

    shared result_0: u1 [x + y + z] 0 
    
    {t1}
    if x[i] = other_x:
        result_0[i * 3]: 1

    {t2}
    if y[i] = other_y:
        result_0[(i * 3) + 1]: 1
    {t3}
    if z[i] = other_z:
        result_0[(i * 3) + 2]: 1
    
    {main}
    result_1: u1 [x] 0
    
    if result_0 * 3[i] = 1
    & result_0[(i * 3) + 1] = 1
    & result_0[(i * 3) + 2] = 1:
        result_1[i]: 1

    return result_1


{t1} # threads are scoped but they do not define scope
var_1: compare3(x, x_other, y, y_other, z, z_other)
var_2: do_something()
var_3: do_something_else()

{main}
var_4: do_unrelated()
var_5: do_related(var_1) # will automatically defer this function call until 'var_1' has returned.
var_6: do_something_else() # if var_1 has not returned, this function will be executed before do_related().

# error handling
try: new_var: do_something()
catch someFault: terminate("this process was now terminated")
catch indexFault: skip

try: other_var: do_something_else()
catch: skip

try: another_var: do_something()
catch: write("just a warning")

# explicit key map
map test_map: i2
    ("key 1": 500),
    ("key 2": 4),
    ("key 3": 650)
    
# implicit key map, types inferred on first item
map test_map_2: ("key 1": 1.0), ("key 2": 2.0)


# string interpolation
var: 32
write("this will write the number &(var)")



write() # defaults to console
read()	# defaults to console

file: "some_file.txt"

allocate bytes: read(file, 0, 500) # reads 500 bytes with 0 start offset. 
write("this is some new content", file)
append("some appended content", file)
create("a_new_textfile.txt")
delete("a_new_textfile.txt")

free(content)



line: Line 
	(Vec2 (0.0, 0.0), Vec2 (1.0, 1.0)),
	(Vec2 (0.0, 0.0), Vec2 (1.0, 1.0)),
	(Vec2 (0.0, 0.0), Vec2 (1.0, 1.0)),
	(Vec2 (0.0, 0.0), Vec2 (1.0, 1.0)),
	(Vec2 (0.0, 0.0), Vec2 (1.0, 1.0)),
	(Vec2 (0.0, 0.0), Vec2 (1.0, 1.0)),
	(Vec2 (0.0, 0.0), Vec2 (1.0, 1.0))


line_copy: line


save_file: "some_file.ltb"

save(line_copy, save_file) # /line_copy(*2(*1(0.0,0.0),*1(0.0,0.0))#0/*#0x6/

new_line: load("line_copy", save_file)







#/
GENERAL KEYWORDS
package, import, inline, shared, map, primitive, 
composite, procedure, return, loop, exit, if, else if, else, 
skip, next, try, catch, lock, unlock, allocate, free,
/#

#/
BUILTIN FUNCTIONS
read(), write(), create(), delete(), append()
evaluate(), terminate(), save(), load()
/#





